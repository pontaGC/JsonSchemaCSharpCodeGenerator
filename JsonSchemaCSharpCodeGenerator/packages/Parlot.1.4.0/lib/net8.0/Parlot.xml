<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parlot</name>
    </assembly>
    <members>
        <member name="T:FastExpressionCompiler.CompilerFlags">
            <summary>The flags for the compiler</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.Default">
            <summary>The default flags: Invocation lambda is inlined, no debug info</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.NoInvocationLambdaInlining">
            <summary>Prevents the inlining of the lambda in the Invocation expression to optimize for the multiple same lambda compiled once</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.EnableDelegateDebugInfo">
            <summary>Adds the Expression, ExpressionString, and CSharpString to the delegate closure for the debugging inspection</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.ThrowOnNotSupportedExpression">
            <summary>When the flag is set then instead of the returning `null` the specific exception is thrown*346</summary>
        </member>
        <member name="F:FastExpressionCompiler.CompilerFlags.DisableInterpreter">
            <summary>Will try to Interpret arithmetic, logical, comparison expressions for the primitive types,
            and emit the IL the result only instead of the whole computation.</summary>
        </member>
        <member name="T:FastExpressionCompiler.NotSupportedExpressionException">
            <summary>FEC Not Supported exception</summary>
        </member>
        <member name="F:FastExpressionCompiler.NotSupportedExpressionException.Reason">
            <summary>The reason</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result)">
            <summary>Constructor</summary>
        </member>
        <member name="M:FastExpressionCompiler.NotSupportedExpressionException.#ctor(FastExpressionCompiler.ExpressionCompiler.Result,System.String)">
            <summary>Constructor</summary>
        </member>
        <member name="T:FastExpressionCompiler.IDelegateDebugInfo">
            <summary>The interface is implemented by the compiled delegate Target if `CompilerFlags.EnableDelegateDebugInfo` is set.</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.Expression">
            <summary>The lambda expression object that was compiled to the delegate</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.ExpressionString">
            <summary>The lambda expression construction syntax C# code</summary>
        </member>
        <member name="P:FastExpressionCompiler.IDelegateDebugInfo.CSharpString">
            <summary>The equivalent C# code of the lambda expression</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFastToIL(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.ILGenerator,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles a static method to the passed IL Generator.
            Could be used as alternative for `CompileToMethod` like this <code><![CDATA[funcExpr.CompileFastToIL(methodBuilder.GetILGenerator())]]></code>.
            Check `IssueTests.Issue179_Add_something_like_LambdaExpression_CompileToMethod.cs` for example.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.LambdaExpression,System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.FromSysExpression``1(System.Linq.Expressions.Expression{``0})">
            <summary>Returns the System expression itself or convert the System expression into Light Expression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.FromSysExpression(System.Linq.Expressions.LambdaExpression)">
            <summary>Returns the System expression itself or convert the System expression into Light Expression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys``1(System.Linq.Expressions.Expression{``0})">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileSys(System.Linq.Expressions.LambdaExpression)">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{``0},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``7(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast(System.Linq.Expressions.Expression{System.Action},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``1(System.Linq.Expressions.Expression{System.Action{``0}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``2(System.Linq.Expressions.Expression{System.Action{``0,``1}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``5(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.CompileFast``6(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean,FastExpressionCompiler.CompilerFlags)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompile``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[])">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of) -
            Constant expression should be the in order of Fields in closure object!
            Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
            Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
            Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ConstantExpression[],FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of)</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCompileWithoutClosure``1(System.Linq.Expressions.LambdaExpression,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo">
            <summary>Collects the lambda info for the compilation</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.Lambda">
            <summary>Compiled lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaExpression">
            <summary>The lambda expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParamMutatedIndexBits">
            <summary>If the N's bit is set, it means the parameter is mutated (assigned or passed by-ref),
            where N is the index of the param in `NonPassedParameters`</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.LambdaVarIndex">
            <summary>Index of the compiled lambda in the parent lambda closure array</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.NonPassedParamsVarIndex">
            <summary>Index of the variable which store the non-passed variables array before passing it to the closure constructor.
            It used to assign the closed variables from the outside of the nested lambda</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo.HasTheSameLambdaExpression(System.Linq.Expressions.LambdaExpression)">
            <summary>Compares 2 lambda expressions for equality</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ClosureInfo">
            Track the info required to build a closure object + some context information not directly related to closure.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.LastEmitIsAddress">
            <summary>Tracks that the last emit was an address</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo._varInBlockMap">
            <summary>Tracks the use of the variables in the blocks stack per variable, 
            (uint) contains (ushort) BlockIndex in the upper bits and (ushort) VarIndex in the lower bits.
            to determine if variable is the local variable and in what block it's defined</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.InlinedLambdaInvocationMap">
            The map of inlined invocations collected in TryCollect and then used in TryEmit
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.ArgsContainingComplexExpression">
            New or Call expressions containing the complex expression, e.g. inlined Lambda Invoke or Try with Finally
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.LambdaInvokeStackLabels">
            The stack for the lambda invocation and the labels bound to them
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.TargetToGotosAndLabels">
            Tracks of how many gotos, labels referencing the specific target, they may be the same gotos expression,
            because the gotos may be reused multiple times in the big expression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.CurrentInlinedLambdaInvokeIndex">
            This is required because we have the return from the nested lambda expression,
            and when inlined in the parent lambda it is no longer the return but just a jump to the label.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.Constants">
            Constant expressions to find an index (by reference) of constant expression from compiled expression.
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.ConstantUsageThenVarIndex">
            Constant usage count and variable index.
            It is a separate collection from the Constants because we directly convert later into the closure array
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NonPassedParameters">
            <summary>Parameters not passed through lambda parameter list But used inside lambda body.
            The top expression should Not contain not passed parameters.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.NestedLambdas">
            <summary>The nested lambdas and their info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus)">
            <summary>Populates the info</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.#ctor(FastExpressionCompiler.ExpressionCompiler.ClosureStatus,System.Object[])">
            <summary>Populates info directly with provided closure object and constants.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.ClosureInfo.PushBlockWithVars(System.Linq.Expressions.ParameterExpression)">
            Local variable index is not known in the collecting phase when we only need to decide if ParameterExpression is an actual parameter or variable
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.IsClosureBoundConstant(System.Object,System.Type)">
            Helps to identify constants as the one to be put into the Closure
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_NewArrayInit_MultidimensionalArray">
            <summary>Multi-dimensional array initializer is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Quote">
            <summary>Quote is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Dynamic">
            <summary>Dynamic is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_RuntimeVariables">
            <summary>RuntimeVariables is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_MemberBinding">
            <summary>MemberInit MemberBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_MemberInit_ListBinding">
            <summary>MemberInit ListBinding is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Try_GotoReturnToTheFollowupLabel">
            <summary>Goto of the Return kind from the TryCatch is not supported</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_Assign_Target">
            <summary>Not supported assignment target</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_TypeEqual">
            <summary>TypeEqual is not supported </summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Result.NotSupported_ExceptionCatchFilter">
            <summary>`when` in catch is not supported yet</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectBoundConstants(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Wraps the call to `TryCollectInfo` for the compatibility and provide the root place to check the returned error code.
            Important: The method collects the info from the nested lambdas up-front and de-duplicates the lambdas as well.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryCollectInfo(FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo,FastExpressionCompiler.ImTools.SmallList{FastExpressionCompiler.ExpressionCompiler.NestedLambdaInfo}@,FastExpressionCompiler.CompilerFlags)">
            <summary>Collects the information about closure constants, nested lambdas, non-passed parameters, goto labels and variables in blocks.
            Returns `OK` result if everything is fine and other result for error.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.TryGetDebugInfo``1(``0)">
            <summary>Return IDelegateDebugInfo if the delegate is fast compiled with `CompilerFlags.EnableDelegateDebugInfo` flag</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.ParentFlags">
            The minimal context-aware flags set by parent
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Empty">
            Default is no flags
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IgnoreResult">
            The result of expression is ignored and maybe popped out
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Call">
            Some parent is the call expression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.MemberAccess">
            Any Parent Expression is a MemberExpression
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Arithmetic">
            Some arithmetic operation
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Coalesce">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceAccess">
            Expression with instance object (method call or member access or array access)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.DupIt">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.TryCatch">
            Subject
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InstanceCall">
            Combination`of InstanceAccess and Call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.Ctor">
            Constructor
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.CtorCall">
            Constructor call
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.IndexAccess">
            Indexer
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.InlinedLambdaInvoke">
            Invoking the inlined lambda (the default System.Expression behavior)
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentLeftValue">
            <summary>Indicate if the part AT LEAST participates in the assignment on the left side, 
            it may also participate in the right side, e.g. ++x.Bar</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentRightValue">
            <summary>Indicates the ONLY right value of assignment, e.g. `p` in `foo.Bar += p` </summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.AssignmentByRef">
            <summary>Assigning the ref of the right value to the left, e.g. in `var a = ref b[1]` we are passing this flag for the `ref b[1]`</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.LambdaCall">
            <summary>Indicates the root lambda call</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.ReturnByRef">
            <summary>ReturnByRef</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.ParentFlags.BlockResult">
            <summary>The block result</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryEmit(System.Linq.Expressions.Expression,System.Collections.Generic.IReadOnlyList{System.Linq.Expressions.ParameterExpression},System.Reflection.Emit.ILGenerator,FastExpressionCompiler.ExpressionCompiler.ClosureInfo@,FastExpressionCompiler.CompilerFlags,FastExpressionCompiler.ExpressionCompiler.ParentFlags,System.Int32)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryEmitPrimitiveOrEnumOrDecimalConstant(System.Reflection.Emit.ILGenerator,System.Object,System.Type)">
            <summary>Emit the IL for the value of the primitive type.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCall(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Get the advantage of the optimized specialized EmitCall method
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitMethodCallOrVirtualCallCheckForNull(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            Same as EmitMethodCallOrVirtualCall which checks the method for null first, and returns false if it is null. 
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.EmitLoadConstantInt(System.Reflection.Emit.ILGenerator,System.Int32)">
            Efficiently emit the int constant
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.EmittingVisitor.TryInterpretAndEmitResult(System.Linq.Expressions.Expression,System.Reflection.Emit.ILGenerator,FastExpressionCompiler.ExpressionCompiler.ParentFlags,FastExpressionCompiler.CompilerFlags)">
            <summary>Tries to interpret and emit the result IL
            In case of exception return false, to allow FEC emit normally and throw in the invocation phase</summary>
        </member>
        <member name="T:FastExpressionCompiler.ExpressionCompiler.Interpreter">
            <summary>Interpreter</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Interpreter.TrueFunc">
            <summary>Always returns true</summary>
        </member>
        <member name="F:FastExpressionCompiler.ExpressionCompiler.Interpreter.FalseFunc">
            <summary>Always returns false</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.UnreachableCase``1(``0,System.String,System.Int32)">
            <summary>Return value should be ignored</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.UnreachableCase``2(``0,``1,System.String,System.Int32)">
            <summary>Return value should be ignored</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.IsComparison(System.Linq.Expressions.ExpressionType)">
            <summary>Operation accepting IComparable inputs and producing bool output</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.IsArithmeticBinary(System.Linq.Expressions.ExpressionType)">
            <summary>Operation accepting the same primitive type inputs (or of the coalescing types) and producing the "same" primitive type output</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.DoArithmeticForPrimitiveValues(FastExpressionCompiler.ExpressionCompiler.Interpreter.PValue@,FastExpressionCompiler.ExpressionCompiler.Interpreter.PValue@,System.TypeCode,System.Linq.Expressions.ExpressionType)">
            <summary>Puts the result to the `left` para meter</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.IsCandidateForInterpretation(System.Linq.Expressions.Expression)">
            <summary>Fast, mostly negative check to skip or proceed with interpretation.
            Depending on the context you may avoid calling it because you know the interpreted expression beforehand,</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.TryInterpretBool(System.Boolean@,System.Linq.Expressions.Expression,FastExpressionCompiler.CompilerFlags)">
            <summary>Wraps `TryInterpretPrimitive` in the try catch block.
            In case of exception FEC will emit the whole computation to throw exception in the invocation phase</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.TryInterpretBool(System.Boolean@,System.Linq.Expressions.Expression,System.Linq.Expressions.ExpressionType)">
            <summary>Tries to interpret the expression of the Primitive type of Constant, Convert, Logical, Comparison, Arithmetic.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.TryInterpretDecimal(System.Decimal@,System.Linq.Expressions.Expression,System.Linq.Expressions.ExpressionType)">
            <summary>Tries to interpret the expression of the Primitive type of Constant, Convert, Logical, Comparison, Arithmetic.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.TryInterpretInt(System.Int32@,System.Linq.Expressions.Expression,System.Linq.Expressions.ExpressionType)">
            <summary>Tries to interpret the expression of the Primitive type of Constant, Convert, Logical, Comparison, Arithmetic.
            Returns `false` if it failed to do so.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ExpressionCompiler.Interpreter.TryInterpretPrimitiveValue(FastExpressionCompiler.ExpressionCompiler.Interpreter.PValue@,System.Linq.Expressions.Expression,System.TypeCode,System.Linq.Expressions.ExpressionType)">
            <summary>Tries to interpret the expression of the Primitive type of Constant, Convert, Logical, Comparison, Arithmetic.
            Returns `false` if it is failed to do so.</summary>
        </member>
        <member name="T:FastExpressionCompiler.Tools">
            <summary>
            Helpers targeting the performance. Extensions method names may be a bit funny (non standard), 
            in order to prevent conflicts with YOUR helpers with standard names
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.Tools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
        </member>
        <member name="M:FastExpressionCompiler.Tools.FindConvertOperator(System.Type,System.Type,System.Type)">
            <summary>Finds the implicit or explicit conversion operator inType from the sourceType to targetType,
            otherwise returns null</summary>
        </member>
        <member name="T:FastExpressionCompiler.ILGeneratorHacks">
            <summary>Reflecting the internal methods to access the more performant for defining the local variable</summary>
        </member>
        <member name="M:FastExpressionCompiler.ILGeneratorHacks.GetNextLocalVarIndex(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>Efficiently returns the next variable index, hopefully without unnecessary allocations.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.ToExpressionPrinter.ToExpressionString(System.Linq.Expressions.Expression,System.Collections.Generic.List{System.Linq.Expressions.ParameterExpression}@,System.Collections.Generic.List{System.Linq.Expressions.Expression}@,System.Collections.Generic.List{System.Linq.Expressions.LabelTarget}@,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>
            Prints the expression in its constructing syntax - 
            helpful to get the expression from the debug session and put into it the code for the test.
            In addition, returns the gathered expressions, parameters ad labels. 
            </summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter">
            <summary>Converts the expression into the valid C# code representation</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="M:FastExpressionCompiler.ToCSharpPrinter.ToCSharpString(System.Linq.Expressions.Expression,System.Text.StringBuilder,System.Int32,System.Boolean,System.Func{System.Type,System.String,System.String},System.Int32,FastExpressionCompiler.CodePrinter.ObjectToCode)">
            <summary>Tries hard to convert the expression into the valid C# code</summary>
        </member>
        <member name="T:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn">
            <summary>Indicates the expression container</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.ParensByDefault">
            <summary>Prefers the parens by default</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.IfTest">
            <summary>The test part of the If expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Block">
            <summary>The `if (test)` part</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.LambdaBody">
            <summary>The lambda</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Return">
            <summary>Return expression</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.AvoidParens">
            <summary>Instructs the client code to avoid parenthesis for the generated C# code, e.g. if we have as single argument in a method</summary>
        </member>
        <member name="F:FastExpressionCompiler.ToCSharpPrinter.EnclosedIn.Instance">
            <summary>The instance when calling the instance method or accessing the instance member</summary>
        </member>
        <member name="T:FastExpressionCompiler.CodePrinter.NamedWithIndex">
            <summary>Named with index indeed</summary>
        </member>
        <member name="F:FastExpressionCompiler.CodePrinter.NamedWithIndex.Named">
            <summary>Named</summary>
        </member>
        <member name="F:FastExpressionCompiler.CodePrinter.NamedWithIndex.Index">
            <summary>Provides an unique suffix for the same named things</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.GetPrimitiveTypeNameAliasOrNull(System.Type)">
            <summary>Returns the standard name (alias) for the well-known primitive type, e.g. Int16 -> short</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Type,System.Boolean,System.Func{System.Type,System.String,System.String},System.Boolean)">
            <summary>Converts the <paramref name="type"/> into the proper C# representation.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Boolean)">
            <summary>Prints valid C# Boolean</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.String)">
            <summary>Prints valid C# String escaping the things</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToEnumValueCode(System.Type,System.Object,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints valid C# Enum literal</summary>
        </member>
        <member name="T:FastExpressionCompiler.CodePrinter.ObjectToCode">
            <summary>Custom handler for output the object in valid C#. 
            Note, the `printGenericTypeArgs` is excluded because it cannot be a open-generic object.
            This handler is also used to allow user to fully control a Constant expression output</summary>
        </member>
        <member name="F:FastExpressionCompiler.CodePrinter.DefaultNotRecognizedToCode">
            <summary>Outputs the `default(Type)` for the unknown constant with the comment message</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCommaSeparatedCode(System.Collections.IEnumerable,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as the array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToArrayInitializerCode(System.Collections.IEnumerable,System.Type,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>Prints many code items as array initializer.</summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.ToCode(System.Object,FastExpressionCompiler.CodePrinter.ObjectToCode,System.Boolean,System.Func{System.Type,System.String,System.String})">
            <summary>
            Prints a valid C# for known <paramref name="x"/>,
            otherwise uses passed <paramref name="notRecognizedToCode"/> or falls back to `ToString()`.
            </summary>
        </member>
        <member name="M:FastExpressionCompiler.CodePrinter.CountLambdas(System.String)">
            <summary>Helper method to find the number of lambdas in the C# code string</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefTools`1">
            <summary>Helpers and polyfills for the missing things in the old .NET versions</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefTools`1.GetNullRef">
            <summary>Polyfill for the missing returning the `ref` in the failed search scenario.
            Note that the result is the `null` even for the struct `T`, so avoid the accessing its members without the check</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList`1">
            <summary>Wrapper for the array of the specific capacity and a separate count less or equal to this capacity </summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Items">
            <summary>Array of items</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList`1.Count">
            <summary>The count of used items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[],System.Int32)">
            <summary>Creating this stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.#ctor(`0[])">
            <summary>Creates the wrapper out of the items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`1.Pop">
            <summary>Popping candy</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList">
            <summary>SmallList module he-he</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultToNotNullItemsAndGetRef``1(``0[]@,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`! 
            `items` should be not null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(``0[]@,System.Int32,System.Int32)">
            <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Add``1(FastExpressionCompiler.ImTools.SmallList{``0}@,System.Int32)">
            <summary>Appends the new default item to the list and returns ref to it for write or read</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Add``1(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,System.Int32)">
            <summary>Appends the new item to the list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(``0[],``0@,System.Int32,System.Int32,``1,System.Int32)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList{``0}@,``0@,``1)">
            <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.Stack4{``0}@,System.Int32)">
            <summary>Returns a surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``2(FastExpressionCompiler.ImTools.SmallList{``0,``1}@,System.Int32)">
            <summary>Returns a surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList4{``0}@,``0@,``1)">
            <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.Enumerate``1(FastExpressionCompiler.ImTools.SmallList4{``0}@)">
            <summary>Enumerates all the items</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerable`1">
            <summary>Enumerable on stack, without allocations</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerable`1.#ctor(FastExpressionCompiler.ImTools.SmallList4{`0})">
            <summary>Constructor</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerable`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerator`1">
            <summary>Enumerator on stack, without allocations</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerator`1.Current">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerator`1.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerator`1.Reset">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.SmallList4Enumerator`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetSurePresentItemRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@,System.Int32)">
            <summary>Returns surely present item ref by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetLastSurePresentItem``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Returns last present item ref, assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.AddDefaultAndGetRef``1(FastExpressionCompiler.ImTools.SmallList2{``0}@)">
            <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.TryGetIndex``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList.GetIndexOrAdd``2(FastExpressionCompiler.ImTools.SmallList2{``0}@,``0,``1)">
            <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.IStack`2">
            <summary>Abstracts over collection of the items on stack of the fixed Capacity,
            to be used as a part of the hybrid data structures which grow from stack to heap</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.IStack`2.Capacity">
            <summary>Count of items holding</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.IStack`2.Item(System.Int32)">
            <summary>Indexer</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IStack`2.Set(System.Int32,`0@)">
            <summary>Set indexed item via value passed by-ref</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IStack`2.GetSurePresentRef(System.Int32)">
            <summary>Gets the ref to the struct T field/item by index. Does not not check the index boundaries - do it externally!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IStack`2.AsSpan">
            <summary>Creates a span from the struct items</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.Stack4`1">
            <summary>Implementation of `IStack` for 4 items on stack</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.Stack4`1.StackCapacity">
            <summary>Count of items on stack</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.Stack4`1.Capacity">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Stack4`1.GetSurePresentRef(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Stack4`1.AsSpan">
            <inheritdoc/>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.Stack4`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Stack4`1.Set(System.Int32,`0@)">
            <summary>Sets the value by the index</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList`2">
            <summary>Generic version of SmallList abstracted for how much items are on stack</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList`2.StackCapacity">
            <inheritdoc />
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList`2.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList`2.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList`2.Add(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList4`1">
            <summary>List with the number of first items (4) stored inside its struct and the rest in the growable array.
            Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList4`1.StackCapacity">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Init1(`0)">
            <summary>Populate with one item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Init2(`0,`0)">
            <summary>Populate with two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Init3(`0,`0,`0)">
            <summary>Populate with 3 items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Init4(`0,`0,`0,`0)">
            <summary>Populate with 4 items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Init(System.Int32,`0@,`0@,`0@,`0@)">
            <summary>Populate with `count` items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Embed(`0,`0,`0,`0,`0[],System.Int32)">
            <summary>Populates the list stack items and owns/uses the provided rest array and its count</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.InitFromList``1(``0)">
            <summary>Populate with arbitrary items</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList4`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Add(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.AddDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.AddList(FastExpressionCompiler.ImTools.SmallList4{`0}@)">
            <summary>Adds another list to the current list</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.DropFirst">
            <summary>Drops the first item out of the list, and shifts the remaining items indices by -1, so the second item become the first and so on.
            If the list is empty the method does nothing.
            The method returns number of the dropped items, e.g. 0 or 1.
            The method is similar to JS Array.shift</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.Clear">
            <summary>Clears the list, but keeps the already allocated array on heap to reuse in the future</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.DropFirstN(System.Int32)">
            <summary>Drops the first `n` items out of the list, and shifts the remaining items indices by -1, so the second item become the first and so on.
            If the list is empty the method does nothing.
            The method returns number of the dropped items, e.g. 0 or 1.
            The method is similar to JS Array.shift</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList4`1.ToArray">
            <summary>Copy items to new the array</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallList2`1">
            <summary>List with the number of first items (2) stored inside its struct and the rest in the growable array.
            Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallList2`1.StackCapacity">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.InitCount(System.Int32)">
            <summary>Good stuff</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate1(`0)">
            <summary>Populate with one item</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate2(`0,`0)">
            <summary>Populate with two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate(`0,`0,`0[])">
            <summary>Populate with more than two items</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Populate``1(``0)">
            <summary>Populate with arbitrary items</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Count">
            <summary>Gets the number of items in the list</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallList2`1.Item(System.Int32)">
            <summary>Returns surely present item by its index</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.Add(`0@)">
            <summary>Adds the item to the end of the list aka the Stack.Push</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.AddDefault">
            <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.RemoveLastSurePresentItem">
            <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallList2`1.ToArray">
            <summary>Copy items to new the array</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.IPrintable">
            <summary>Printable thing via provided printer </summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IPrintable.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <summary>Print to the provided string builder via the provided printer.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.Hasher">
            <summary>Produces good enough hash codes for the fields</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Hasher.Combine``2(``0,``1)">
            <summary>Combines hashes of two fields</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.IEq`1">
            <summary>Configures removed key tombstone, equality and hash function for the SmallMap and friends</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IEq`1.GetTombstone">
            <summary>Defines the value of the key indicating the removed entry</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.DefaultEq`1">
            <summary>Default comparer using the `object.GetHashCode` and `object.Equals` overloads</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.DefaultEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.IntEq">
            <summary>Uses the integer itself as hash code and `==` for equality</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IntEq.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IntEq.Equals(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.IntEq.GetHashCode(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq">
            <summary>Instances of the RefEq for the often used K</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.RefEq.OfObject">
            <summary>RefEq for object, possibly the only thing you need</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`1">
            <summary>Uses the `object.GetHashCode` and `object.ReferenceEquals`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`2">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.Equals(System.ValueTuple{`0,`1},System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`2.GetHashCode(System.ValueTuple{`0,`1})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.RefEq`3">
            <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.GetTombstone">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.Equals(System.ValueTuple{`0,`1,`2},System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="M:FastExpressionCompiler.ImTools.RefEq`3.GetHashCode(System.ValueTuple{`0,`1,`2})">
            <inheritdoc />
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4">
            <summary>Configuration and the tools for the SmallMap and friends</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.MaxProbeBits">
            <summary>Upper hash bits spent on storing the probes, e.g. 5 bits mean 31 probes max.</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.StackEntriesCount">
            <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.New``3(System.Byte)">
            <summary>Creates the map with the <see cref="T:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3"/> storage</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.Entry`2">
            <summary>Holds a single entry consisting of key and value. 
            Value may be set or changed but the key is set in stone (by construction).</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.Key">
            <summary>The readonly key</summary>
        </member>
        <member name="F:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.Value">
            <summary>The mutable value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.#ctor(`0)">
            <summary>Construct with the key and default value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.Entry`2.#ctor(`0,`1)">
            <summary>Construct with the key and value</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.ToB(System.Int32)">
            binary representation of the `int`
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3">
            <summary>Abstraction to configure your own entries data structure. Check the derived types for the examples</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.Init(System.Byte)">
            <summary>Initializes the entries storage to the specified capacity via the number of <paramref name="capacityBitShift"/> bits in the capacity</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.GetSurePresentEntryRef(System.Int32)">
            <summary>Returns the reference to entry by its index, index should map to the present/non-removed entry</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.IEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <summary>Adds the key at the "end" of entries - so the order of addition is preserved.</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.NoValue">
            <summary>For now to use in the Set as a value</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3">
            <summary>Stores the entries in a single dynamically reallocated growing array</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.Init(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.GetSurePresentEntryRef(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.SingleArrayEntries`3.AddKeyAndGetValueRef(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.TryGetValueRefUnsafe``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Finds the stored value by key.
            UNSAFE: don't try to set the returned value if the `found == false`, because you will be setting the shared static value.
            You may set the value ONLY if `found == true`,
            If you want this kind of sematic use `AddOrGetValueRef`</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.ContainsKey``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0)">
            <summary>Finds the stored value by key. If found returns ref to the value it can be modified in place.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.AddOrGetValueRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0,System.Boolean@)">
            <summary>Gets the reference to the existing value by the provided key (found == true),
            or adds a new key-value pair (found == false) and allows to set the returned value.</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.AddSureAbsentDefaultAndGetRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,``0)">
            <summary>Adds the sure absent key entry. 
            Provides the performance in scenarios where you look for present key, and using it, and if ABSENT then add the new one.
            So this method optimized NOT to look for the present item for the second time in SEQUENCE</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4.GetSurePresentEntryRef``4(FastExpressionCompiler.ImTools.SmallMap4{``0,``1,``2,``3}@,System.Int32)">
            <summary>Get the value ref by the entry index. Also the index corresponds to entry adding order.
             Important: it does not check the index bounds, so you need to check that the index is from 0 to map.Count-1</summary>
        </member>
        <member name="T:FastExpressionCompiler.ImTools.SmallMap4`4">
            <summary>
            Fast and less-allocating hash map without thread safety nets. Please measure it in your own use case before use.
            It is configurable in regard of hash calculation/equality via `TEq` type parameter and 
            in regard of key-value storage via `TEntries` type parameter.
            
            Details:
            - Implemented as a struct so that the empty/default map does not allocate on heap
            - Hashes and key-values are the separate collections enabling better cash locality and faster performance (data-oriented design)
            - No SIMD for now to avoid complexity and costs for the smaller maps, so the map is more fit for the smaller sizes.
            - Provides the "stable" enumeration of the entries in the added order
            - The TryRemove method removes the hash but replaces the key-value entry with the tombstone key and the default value.
            For instance, for the `RefEq` the tombstone is <see langword="null"/>. You may redefine it in the `IEq{K}.GetTombstone()` implementation.
            
            </summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.CapacityBitShift">
            <summary>Capacity bits</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.PackedHashesAndIndexes">
            <summary>Access to the hashes and indexes</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.Count">
            <summary>Number of entries in the map</summary>
        </member>
        <member name="P:FastExpressionCompiler.ImTools.SmallMap4`4.Entries">
            <summary>Access to the key-value entries</summary>
        </member>
        <member name="M:FastExpressionCompiler.ImTools.SmallMap4`4.#ctor(System.Byte)">
            <summary>Capacity calculates as `1 leftShift capacityBitShift`</summary>
        </member>
        <member name="T:Parlot.CharMap`1">
            <summary>
            Combines maps of ascii and non-ascii characters.
            If all characters are ascii, the non-ascii dictionary is not used.
            </summary>
        </member>
        <member name="T:Parlot.CharToStringTable">
            <summary>
            Cache of char to string mapping to reduce allocations
            when doing chars comparisons.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.CompilationContext">
            <summary>
            Represents the context of a compilation phase, coordinating all the parsers involved.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.ParseContext">
            <summary>
            Gets the expression containing the the <see cref="P:Parlot.Compilation.CompilationContext.ParseContext"/> instance for the parser.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.NextNumber">
            <summary>
            Gets or sets a counter used to generate unique variable names.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.GlobalVariables">
            <summary>
            Gets the list of global variables to add the the final list of statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.GlobalExpressions">
            <summary>
            Gets the list of global expressions to add the the final list of statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.Lambdas">
            <summary>
            Gets the list of shared lambda expressions representing intermediate parsers.
            </summary>
            <remarks>
            This is used for debug only, in order to inspect the source generated for these intermediate parsers.
            </remarks>
        </member>
        <member name="P:Parlot.Compilation.CompilationContext.DiscardResult">
            <summary>
            Gets or sets whether the current compilation phase should ignore the results of the parsers.
            </summary>
            <remarks>
            When set to true, the compiled statements don't need to record and define the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> property.
            This is done to optimize compiled parser that are usually used for pattern matching only.
            </remarks>
        </member>
        <member name="M:Parlot.Compilation.CompilationContext.CreateCompilationResult``1(System.Boolean,System.Linq.Expressions.Expression)">
            <summary>
            Creates a <see cref="T:Parlot.Compilation.CompilationResult"/> instance with a <see cref="P:Parlot.Compilation.CompilationResult.Value"/> and <see cref="P:Parlot.Compilation.CompilationResult.Success"/>
            variables.
            </summary>
            <typeparam name="TValue">The type of the value returned by the parser instance.</typeparam>
            <param name="defaultSuccess">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Success"/> variable.</param>
            <param name="defaultValue">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> variable.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Compilation.CompilationContext.CreateCompilationResult(System.Type,System.Boolean,System.Linq.Expressions.Expression)">
            <summary>
            Creates a <see cref="T:Parlot.Compilation.CompilationResult"/> instance with a <see cref="P:Parlot.Compilation.CompilationResult.Value"/> and <see cref="P:Parlot.Compilation.CompilationResult.Success"/>
            variables.
            </summary>
            <param name="valueType">The type of the value returned by the parser instance.</param>
            <param name="defaultSuccess">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Success"/> variable.</param>
            <param name="defaultValue">The default value of the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> variable.</param>
            <returns></returns>
        </member>
        <member name="T:Parlot.Compilation.CompilationResult">
            <summary>
            Every parser that is compiled returns an instance of <see cref="T:Parlot.Compilation.CompilationResult"/> which encapsulates the statements to execute in order
            to parse the expected input.
            The convention is that these statements are returned in the <see cref="P:Parlot.Compilation.CompilationResult.Body"/> property, and any variable that needs to be declared in the block
            that the <see cref="P:Parlot.Compilation.CompilationResult.Body"/> is used in are set in the <see cref="P:Parlot.Compilation.CompilationResult.Variables"/> list.
            The <see cref="P:Parlot.Compilation.CompilationResult.Success"/> property represents the variable that contains the success of the statements once executed, and if <code>true</code> then 
            the <see cref="P:Parlot.Compilation.CompilationResult.Value"/> property contains the result.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Variables">
            <summary>
            Gets the list of <see cref="T:System.Linq.Expressions.ParameterExpression"/> representing the variables used by the compiled result.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Body">
            <summary>
            Gets the list of <see cref="T:System.Linq.Expressions.Expression"/> representing the body of the compiled results.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Success">
            <summary>
            Gets or sets the <see cref="T:System.Linq.Expressions.ParameterExpression"/> of the <see cref="T:System.Boolean"/> variable representing the success of the parsing statements.
            </summary>
        </member>
        <member name="P:Parlot.Compilation.CompilationResult.Value">
            <summary>
            Gets or sets the <see cref="T:System.Linq.Expressions.ParameterExpression"/> of the <see cref="T:System.Boolean"/> variable representing the value of the parsing statements.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.ICompiledParser">
            <summary>
            Marker interface to detect a Parser has already been compiled.
            </summary>
        </member>
        <member name="T:Parlot.Compilation.CompiledParser`1">
            <summary>
            An instance of this class encapsulates the result of a compiled parser
            in order to expose is as as standard parser contract.
            </summary>
            <remarks>
            This class is used in <see cref="M:Parlot.Fluent.Parser`1.Compile"/>.
            </remarks>
        </member>
        <member name="M:Parlot.Compilation.ICompilable.Compile(Parlot.Compilation.CompilationContext)">
            <summary>
            Creates a compiled representation of a parser.
            </summary>
            <param name="context">The current compilation context.</param>
        </member>
        <member name="P:Parlot.Cursor.Span">
            <summary>
            Returns the <see cref="T:System.ReadOnlySpan`1"/> value of the <see cref="P:Parlot.Cursor.Buffer" /> at the current offset.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Advance">
            <summary>
            Advances the cursor by one character.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Advance(System.Int32)">
            <summary>
            Advances the cursor and tracks its current location (line and column).
            </summary>
        </member>
        <member name="M:Parlot.Cursor.AdvanceNoNewLines(System.Int32)">
            <summary>
            Advances the cursor and tracks its current location (line and column) with the knowledge there are no new lines (\r or \n).
            </summary>
        </member>
        <member name="M:Parlot.Cursor.ResetPosition(Parlot.TextPosition@)">
            <summary>
            Moves the cursor to the specific position
            </summary>
        </member>
        <member name="P:Parlot.Cursor.Current">
            <summary>
            Evaluates the char at the current position.
            </summary>
        </member>
        <member name="P:Parlot.Cursor.Offset">
            <summary>
            Returns the cursor's position in the _buffer.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.PeekNext(System.Int32)">
            <summary>
            Evaluates a char forward in the _buffer.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.Char)">
            <summary>
            Whether a char is at the current position.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.ReadOnlySpan{System.Char})">
            <summary>
            Whether a string is at the current position.
            </summary>
        </member>
        <member name="M:Parlot.Cursor.Match(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Whether a string is at the current position.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Always`1">
            <summary>
            Doesn't parse anything and return the default value.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Discard`2">
            <summary>
            Doesn't parse anything and return the default value.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Else`1">
            <summary>
            Returns a default value if the previous parser failed.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Eof`1">
            <summary>
            Successful when the cursor is at the end of the string.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.If`3">
            <summary>
            Ensure the given parser is valid based on a condition, and backtracks if not.
            </summary>
            <typeparam name="C">The concrete <see cref="T:Parlot.Fluent.ParseContext" /> type to use.</typeparam>
            <typeparam name="S">The type of the state to pass.</typeparam>
            <typeparam name="T">The output parser type.</typeparam>
        </member>
        <member name="T:Parlot.Fluent.NumberLiteralBase`1">
            <summary>
            This class is used as a base class for custom number parsers which don't implement INumber<typeparamref name="T"/> after .NET 7.0.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.None">
            <summary>
            Indicates that no style elements, such as leading sign, thousands
            separators, decimal separator or exponent, can be present in the parsed string.
            The string to be parsed must consist of integral decimal digits only.        
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowLeadingSign">
            <summary>
            Indicates that the numeric string can have a leading sign. Valid leading sign
            characters are plus (+) and minus (-).
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator">
            <summary>
            Indicates that the numeric string can have a decimal separator. By default it uses dot (.) as the separator.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowGroupSeparators">
            <summary>
            Indicates that the numeric string can have group separators, such as symbols
            that separate hundreds from thousands. the default group separator is comma (,).
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.AllowExponent">
            <summary>
            Indicates that the numeric string can be in exponential notation. It
            allows the parsed string to contain an exponent that begins with the "E"
            or "e" character and that is followed by an optional positive or negative sign
            and an integer.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Integer">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>
            style is used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Number">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowGroupSeparators"/>
            styles are used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Float">
            <summary>
            Indicates that the <see cref="F:Parlot.Fluent.NumberOptions.AllowLeadingSign"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowDecimalSeparator"/>, <see cref="F:Parlot.Fluent.NumberOptions.AllowExponent"/>
            styles are used. This is a composite number style.
            </summary>
        </member>
        <member name="F:Parlot.Fluent.NumberOptions.Any">
            <summary>
            Indicates that all options are used.
            This is a composite number style.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.OneOf`1">
            <summary>
            OneOf the inner choices when all parsers return the same type.
            We then return the actual result of each parser.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Parlot.Fluent.OneOf`1.OriginalParsers">
            <summary>
            Gets the parsers before they get SkipWhitespace removed.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Optional`1">
            <summary>
            Returns a list containing zero or one element.
            </summary>
            <remarks>
            This parser will always succeed. If the previous parser fails, it will return an empty list.
            </remarks>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.CompilationThreshold">
            <summary>
            The number of usages of the parser before it is compiled automatically. <c>0</c> to disable automatic compilation. Default is 0.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.UseNewLines">
            <summary>
            Whether new lines are treated as normal chars or white spaces. Default is <c>false</c>.
            </summary>
            <remarks>
            When <c>false</c>, new lines will be skipped like any other white space.
            Otherwise new lines need to be read explicitly by a rule.
            </remarks>
        </member>
        <member name="F:Parlot.Fluent.ParseContext.Scanner">
            <summary>
            The scanner used for the parsing session.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.OnEnterParser">
            <summary>
            Delegate that is executed whenever a parser is invoked.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.OnExitParser">
            <summary>
            Delegate that is executed whenever a parser is left.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.ParseContext.WhiteSpaceParser">
            <summary>
            The parser that is used to parse whitespaces and comments.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.ParseContext.EnterParser``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Called whenever a parser is invoked.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.ParseContext.ExitParser``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Called whenever a parser exits.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Compile">
            <summary>
            Compiles the current parser.
            </summary>
            <returns>A compiled parser.</returns>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Build(Parlot.Compilation.CompilationContext,System.Boolean)">
            <summary>
            Invokes the <see cref="M:Parlot.Compilation.ICompilable.Compile(Parlot.Compilation.CompilationContext)"/> method of the <see cref="T:Parlot.Fluent.Parser`1"/> if it's available or 
            creates a generic one.
            </summary>
            <param name="context">The <see cref="T:Parlot.Compilation.CompilationContext"/> instance.</param>
            <param name="requireResult">Forces the instruction to compute the resulting value whatever the state of <see cref="P:Parlot.Compilation.CompilationContext.DiscardResult"/> is.</param>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(System.Func{`0,``0})">
            <summary>
            Builds a parser that converts the previous result when it succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(System.Func{Parlot.Fluent.ParseContext,`0,``0})">
            <summary>
            Builds a parser that converts the previous result, and can alter the current <see cref="T:Parlot.Fluent.ParseContext"/>.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1(``0)">
            <summary>
            Builds a parser that converts the previous result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Then``1">
            <summary>
            Builds a parser that converts the previous result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(System.Func{`0,``0},``0)">
            <summary>
            Builds a parser that converts the previous result when it succeeds or returns a default value if it fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(System.Func{Parlot.Fluent.ParseContext,`0,``0},``0)">
            <summary>
            Builds a parser that converts the previous result or returns a default value if it fails, and can alter the current <see cref="T:Parlot.Fluent.ParseContext"/>.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ThenElse``1(``0,``0)">
            <summary>
            Builds a parser that converts the previous result or returns a default value if it fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.ElseError(System.String)">
            <summary>
            Builds a parser that emits an error when the previous parser failed.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Error(System.String)">
            <summary>
            Builds a parser that emits an error.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Error``1(System.String)">
            <summary>
            Builds a parser that emits an error.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Named(System.String)">
            <summary>
            Names a parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.When(System.Func{`0,System.Boolean})">
            <summary>
            Builds a parser that verifies the previous parser result matches a predicate.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.When(System.Func{Parlot.Fluent.ParseContext,`0,System.Boolean})">
            <summary>
            Builds a parser that verifies the previous parser result matches a predicate.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Switch``1(System.Func{Parlot.Fluent.ParseContext,`0,Parlot.Fluent.Parser{``0}})">
            <summary>
            Builds a parser what returns another one based on the previous result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Eof">
            <summary>
            Builds a parser that ensures the cursor is at the end of the input.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Discard``1">
            <summary>
            Builds a parser that discards the previous result and replaces it by the specified type or value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Discard``1(``0)">
            <summary>
            Builds a parser that discards the previous result and replaces it by the specified type or value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Else(`0)">
            <summary>
            Builds a parser that returns a default value if the previous parser fails.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Lookup(System.Boolean,System.ReadOnlySpan{System.Char})">
            <summary>
            Builds a parser that lists all possible matches to improve performance.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parser`1.Lookup(Parlot.Rewriting.ISeekable[])">
            <summary>
            Builds a parser that lists all possible matches to improve performance.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.Parser`1.Name">
            <summary>
            Gets or sets the text which is to render the textual representation of the parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.And``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AndSkip``8(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5,``6},Parlot.Fluent.Parser{``7})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.Parsers.Literals">
            <summary>
            Provides parsers for literals. Literals do not skip spaces before being parsed and can be combined to
            parse composite terms.
            </summary>
        </member>
        <member name="P:Parlot.Fluent.Parsers.Terms">
            <summary>
            Provides parsers for terms. Terms skip spaces before being parsed.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Separated``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that looks for zero or many times a parser separated by another one.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipWhiteSpace``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that skips white spaces before another one.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrOne``1(Parlot.Fluent.Parser{``0},``0)">
            <summary>
            Builds a parser that looks for zero or one time the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrOne``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for zero or one time the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.ZeroOrMany``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for zero or many times the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.OneOrMany``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that looks for one or many times the specified parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Not``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that succeeds when the specified parser fails to match.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.If``3(System.Func{``0,``1,System.Boolean},``1,Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that invoked the next one if a condition is true.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.If``2(System.Func{Parlot.Fluent.ParseContext,``0,System.Boolean},``0,Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that invoked the next one if a condition is true.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.If``2(System.Func{``0,System.Boolean},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that invoked the next one if a condition is true.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.If``1(System.Func{Parlot.Fluent.ParseContext,System.Boolean},Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that invoked the next one if a condition is true.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Deferred``1">
            <summary>
            Builds a parser that can be defined later one. Use it when a parser need to be declared before its rule can be set.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Recursive``1(System.Func{Parlot.Fluent.Deferred{``0},Parlot.Fluent.Parser{``0}})">
            <summary>
            Builds a parser than needs a reference to itself to be declared.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Between``3(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that matches the specified parser between two other ones.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.AnyCharBefore``1(Parlot.Fluent.Parser{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Builds a parser that matches any chars before a specific parser.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Capture``1(Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that captures the output of another parser.
            This is used to provide pattern matching capabilities, and optimized compiled parsers that then don't need to materialize each parser result.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always``1">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Always``1(``0)">
            <summary>
            Builds a parser that always succeeds.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Or``1(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``0})">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Or``3(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.OneOf``1(Parlot.Fluent.Parser{``0}[])">
            <summary>
            Builds a parser that return either of the first successful of the specified parsers.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``2(Parlot.Fluent.Parser{``0},Parlot.Fluent.Parser{``1})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``3(Parlot.Fluent.Sequence{``0,``1},Parlot.Fluent.Parser{``2})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``4(Parlot.Fluent.Sequence{``0,``1,``2},Parlot.Fluent.Parser{``3})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``5(Parlot.Fluent.Sequence{``0,``1,``2,``3},Parlot.Fluent.Parser{``4})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``6(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4},Parlot.Fluent.Parser{``5})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``7(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5},Parlot.Fluent.Parser{``6})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.SkipAnd``8(Parlot.Fluent.Sequence{``0,``1,``2,``3,``4,``5,``6},Parlot.Fluent.Parser{``7})">
            <summary>
            Builds a parser that ensure the specified parsers match consecutively. The last parser's result is then ignored.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.Parsers.LeftAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a left-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // additive => multiplicative(("-" | "+") multiplicative) * ;
            var additive = multiplicative.LeftAssociative(
                (plus, static (a, b) => new Addition(a, b)),
                (minus, static (a, b) => new Subtraction(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.LeftAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a left-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // additive => multiplicative(("-" | "+") multiplicative) * ;
            var additive = multiplicative.LeftAssociative(
                (plus, static (a, b) => new Addition(a, b)),
                (minus, static (a, b) => new Subtraction(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.RightAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a right-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // exponentiation => primary( ("^") primary) * ;
            var exponentiation = primary.RightAssociative(
                (equal, static (a, b) => new Exponent(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.RightAssociative``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0,``0}}[])">
            <summary>
            Builds a parser that creates a right-associative structure.
            c.f. https://en.wikipedia.org/wiki/Operator_associativity
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
            <example>
            // exponentiation => primary( ("^") primary) * ;
            var exponentiation = primary.RightAssociative(
                (equal, static (a, b) => new Exponent(a, b))
                );
            </example>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Unary``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{``0,``0}}[])">
            <summary>
            Builds a parser that creates a unary operation.
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Fluent.Parsers.Unary``2(Parlot.Fluent.Parser{``0},System.ValueTuple{Parlot.Fluent.Parser{``1},System.Func{Parlot.Fluent.ParseContext,``0,``0}}[])">
            <summary>
            Builds a parser that creates a unary operation.
            </summary>
            <typeparam name="T">The type of the returned parser.</typeparam>
            <typeparam name="TInput">The type of the symbol parsers.</typeparam>
            <param name="parser">The higher-priority parser the symbols are separating.</param>
            <param name="list">The list of operators that can be parsed and their associated result factory methods.</param>
            <returns></returns>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.WhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.NonWhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches anything until whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Text(System.String,System.Boolean)">
            <summary>
            Builds a parser that matches the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Char(System.Char)">
            <summary>
            Builds a parser that matches the specified char.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Number``1(Parlot.Fluent.NumberOptions,System.Char,System.Char)">
            <summary>
            Builds a parser that matches a number and returns any numeric type.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Integer(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches an integer with an option leading sign.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Decimal(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Float(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Double(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.String(Parlot.Fluent.StringLiteralQuotes)">
            <summary>
            Builds a parser that matches an quoted string that can be escaped.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Identifier(System.Func{System.Char,System.Boolean},System.Func{System.Char,System.Boolean})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Identifier(System.Buffers.SearchValues{System.Char},System.Buffers.SearchValues{System.Char})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Identifier(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.Pattern(System.Func{System.Char,System.Boolean},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a char against a predicate.
            </summary>
            <param name="predicate">The predicate to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.AnyOf(System.Buffers.SearchValues{System.Char},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a list of chars.
            </summary>
            <param name="searchValues">The <see cref="T:System.Buffers.SearchValues`1"/> instance to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.LiteralBuilder.AnyOf(System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a list of chars.
            </summary>
            <param name="values">The set of char to match.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.NonWhiteSpace(System.Boolean)">
            <summary>
            Builds a parser that matches anything until whitespaces.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Text(System.String,System.Boolean)">
            <summary>
            Builds a parser that matches the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Char(System.Char)">
            <summary>
            Builds a parser that matches the specified char.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Number``1(Parlot.Fluent.NumberOptions,System.Char,System.Char)">
            <summary>
            Builds a parser that matches a number and returns any numeric type.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Integer(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches an integer with an option leading sign.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Decimal(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Float(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Double(Parlot.Fluent.NumberOptions)">
            <summary>
            Builds a parser that matches a floating point number represented as a <lang cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.String(Parlot.Fluent.StringLiteralQuotes)">
            <summary>
            Builds a parser that matches an quoted string that can be escaped.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Identifier(System.Func{System.Char,System.Boolean},System.Func{System.Char,System.Boolean})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Identifier(System.Buffers.SearchValues{System.Char},System.Buffers.SearchValues{System.Char})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Identifier(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Builds a parser that matches an identifier which can have a different starting value that the rest of its chars.
            </summary>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.Pattern(System.Func{System.Char,System.Boolean},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a char against a predicate.
            </summary>
            <param name="predicate">The predicate to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.AnyOf(System.Buffers.SearchValues{System.Char},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a list of chars.
            </summary>
            <param name="searchValues">The <see cref="T:System.Buffers.SearchValues`1"/> instance to match against each char.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="M:Parlot.Fluent.TermBuilder.AnyOf(System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Builds a parser that matches a list of chars.
            </summary>
            <param name="values">The set of char to match.</param>
            <param name="minSize">The minimum number of matches required. Defaults to 1.</param>
            <param name="maxSize">When the parser reaches the maximum number of matches it returns <see langword="True"/>. Defaults to 0, i.e. no maximum size.</param>
        </member>
        <member name="T:Parlot.Fluent.Seekable`1">
            <summary>
            Wraps an existing parser as an <see cref="T:Parlot.Rewriting.ISeekable"/> implementation by provide the seekable properties.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Switch`2">
            <summary>
            Routes the parsing based on a custom delegate.
            </summary>
        </member>
        <member name="T:Parlot.Fluent.Then`2">
            <summary>
            Returns a new <see cref="T:Parlot.Fluent.Parser`1" /> converting the input value of 
            type T to the output value of type U using a custom function.
            </summary>
            <typeparam name="T">The input parser type.</typeparam>
            <typeparam name="U">The output parser type.</typeparam>
        </member>
        <member name="T:Parlot.Fluent.When`1">
            <summary>
            Ensure the given parser is valid based on a condition, and backtracks if not.
            </summary>
            <typeparam name="T">The output parser type.</typeparam>
        </member>
        <member name="T:Parlot.Rewriting.IRewritable`1">
            <summary>
            A Parser implementing this interface can be rewritten in a more optimized way.
            The result will replace the instance.
            </summary>
        </member>
        <member name="M:Parlot.Rewriting.IRewritable`1.Rewrite">
            <summary>
            Returns the parser to substitute.
            </summary>
        </member>
        <member name="T:Parlot.Rewriting.ISeekable">
            <summary>
            A Parser implementing this interface can only be triggered if the next char matches the one provided.
            It is used to create char lookups to optimize which Parsers need to be invoked next.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.CanSeek">
            <summary>
            Gets whether the current parser can be selected from a single char.
            This could vary based on the subsequent parsers.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.ExpectedChars">
            <summary>
            Gets the chars that can be matched next to evaluate this Parser.
            </summary>
        </member>
        <member name="P:Parlot.Rewriting.ISeekable.SkipWhitespace">
            <summary>
            Gets whether the current parser needs to skip whitespaces before being invoked.
            </summary>
        </member>
        <member name="T:Parlot.Scanner">
            <summary>
            This class is used to return tokens extracted from the input buffer.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.#ctor(System.String)">
            <summary>
            Scans some text.
            </summary>
            <param name="buffer">The string containing the text to scan.</param>
        </member>
        <member name="M:Parlot.Scanner.SkipWhiteSpaceOrNewLine">
            <summary>
            Reads any whitespace without generating a token.
            </summary>
            <returns>Whether some white space was read.</returns>
        </member>
        <member name="M:Parlot.Scanner.ReadWhile(System.Func{System.Char,System.Boolean})">
            <summary>
            Reads a token while the specific predicate is valid.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadWhile(System.Func{System.Char,System.Boolean},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads a token while the specific predicate is valid.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadChar(System.Char)">
            <summary>
            Reads the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadChar(System.Char,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specified text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.StringComparison,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadAnyOf(System.ReadOnlySpan{System.Char},System.StringComparison,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected chars.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadAnyOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected chars.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadAnyOf(System.Buffers.SearchValues{System.Char},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected chars.
            </summary>
            <remarks>
            This overload uses <see cref="T:System.Buffers.SearchValues"/> as this shouldn't be created on every call. The actual implementation of
            <see cref="T:System.Buffers.SearchValues"/> is chosen based on the constituents of the list. The caller should thus reuse the instance.
            </remarks>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char})">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadText(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads the specific expected text.
            </summary>
        </member>
        <member name="M:Parlot.Scanner.ReadQuotedString(System.Char,System.ReadOnlySpan{System.Char}@)">
            <summary>
            Reads a string token enclosed in quotes or custom characters.
            </summary>
            <remarks>
            This method doesn't escape the string, but only validates its content is syntactically correct.
            The resulting Span contains the original quotes.
            </remarks>
        </member>
        <member name="T:Parlot.TextPosition">
            <summary>
            Represents a position in a text buffer.
            </summary>
        </member>
        <member name="P:HexConverter.CharToHexLookup">
            <summary>Map from an ASCII char to its hex value, e.g. arr['b'] == 11. 0xFF means it's not a hex digit.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution. When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ParamCollectionAttribute">
            <summary>
            Indicates that a method will allow a variable number of arguments in its invocation.
            </summary>
        </member>
    </members>
</doc>
